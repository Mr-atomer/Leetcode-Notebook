# Day_1_数据结构与算法&LeetCode入门及攻略

- ## 数据结构与算法

  学习目的：我们学习算法和数据结构，是为了学会在编程中从**时间复杂度、空间复杂度**方面考虑解决方案，训练自己的**逻辑思维**，从					而写出高质量的代码，以此提升自己的编程技能，获取更高的工作回报。

  - ### 数据结构

    定义：数据结构 (Data Structure) 指的是带有**结构特性**的数据元素的集合。

    学习的目的：为了帮助我们了解和掌握计算机中的数据是以何种方式进行组织、存储的。

    #### 	Q1：何为结构特性？

    ​	所谓结构特性，指的是数据的逻辑结构，物理结构及它们之间的关系

    - ##### 逻辑结构：数据元素之间的相互关系

    ​	根据元素之间的不同关系，我们将逻辑结构细分为以下四种：

    1. ​	集合结构：元素之间仅共处同一集合，除此外并无其它关系，此集合的性质与数学上的 "集合" 非常相似，如无序性、唯一性、元素不重复等。

    	![](C:\Users\atomer\Desktop\屏幕截图 2021-11-15 171354.jpg)

    2. ​    线性结构：即 "一对一" 的结构关系，常见的数组、链表、哈希表等都属于线性结构。

    	![](C:\Users\atomer\Desktop\屏幕截图 2021-11-15 172608.jpg)

    3. ​    树状结构：即 "一对多" 的结构关系，结构中第一个元素称为 "根" ，其余元素称为 "子树"，常见的树状结构有：二叉树、多叉树、字典树等。

    	![](C:\Users\atomer\Desktop\屏幕截图 2021-11-15 172621.jpg)

    4. ​    图形结构：即 "多对多" 的结构关系，与线性结构不同，图形结构是一种非线性的数据结构，由一些小圆点（称为顶点或结点）和连结这些圆点的直线或曲线（称为边）组成。结点之间的邻接关系可以是任意的。常见的图形结构有：无向图、有向图、连通图等

    	![](C:\Users\atomer\Desktop\屏幕截图 2021-11-15 172632.jpg)

    	- ##### 物理结构：数据的逻辑结构在计算机中的存储方式。

    		数据在计算机中的存储形式是多样的，比较常用的是以下两种。

    		1. ​    *顺序存储结构* ：将数据按顺序放置在一片地址连续的存储单元里。这样的存储结构中，逻辑上相邻的元素 (如上图	线性结构里的元素 0 和元素 1) 在物理地址上也必然相邻。

    			​	优点：简单、易理解、占用的空间少

    			​	缺点：需要占用连续的存储空间，且存储空间必须事先分配，对于插入、移动、删除元素等操作时间效率低。

    		2. ​    *链式存储结构* ：将数据存放在任意的存储单元里，存储单元的地址不一定连续。

    			​    优点：存储空间不必事先分配，不会浪费存储空间，对于插入、移动、删除元素等操作时间效率较高。

    			​    缺点：存储空间开销大 (每个存储单元除了要存储数据本身之外，还要存储指针)

    			> ​    指针：指出某数据元素在逻辑关系的直接后继元素所在链结点的地址

    #### 	Q2：为什么要研究数据的结构特性？

    ​	为了提高计算机硬件的利用率。这里引用《算法通关手册 (数据结构与算法) 》中的一个例子：

    ​	操作系统想要查找应用程序 「Microsoft Word」 在硬盘中的哪一个位置存储。如果对硬盘全部扫描一遍的话肯定效率很低，	但如果使用 [B+数] 作为索引，就能很容易的搜索到 `Microsoft Word` 这个单词，然后很快的定位到 「Microsoft Word」这个	应用程序的文件信息，从而从文件信息中找到对应的磁盘位置。

    > 备注：B+树即B+ Tree结构 (平衡多路查找树)，相关学习链接如下：
    >
    > [B-Tree和B+Tree详解](https://blog.csdn.net/yin767833376/article/details/81511377)
    >
    > [数据库索引](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/8751686#:~:text=%E7%B4%A2%E5%BC%95%20%E6%98%AF%E5%AF%B9,%E6%95%B0%E6%8D%AE%E5%BA%93%20%E8%A1%A8%E4%B8%AD%E4%B8%80%E5%88%97%E6%88%96%E5%A4%9A%E5%88%97%E7%9A%84%E5%80%BC%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E5%8F%AF%E5%BF%AB%E9%80%9F%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%89%B9%E5%AE%9A%E4%BF%A1%E6%81%AF%E3%80%82)
    >
    > [MySQL为什么要用B+树实现索引](https://cloud.tencent.com/developer/article/1543335)

  - ### 算法

    定义：解决特定问题求解步骤的准确而完整的描述，在计算机中表现为一系列指令的集合，算法代表着用系统的方法描述解决问			题的策略机制，可简单的理解为：解决问题的方法。

    解决某一问题可能有不同的算法，这些算法虽然都指向了同一个结果，但返回这个结果所需的时间和空间不尽相同。因此，一个优秀的算法，应该至少追求以下两个目标：**更快 (更低的时间复杂度)，更轻 (更低的空间复杂度)**

    然而，现实中的算法，往往是需要同时从运行时间、占用空间两个方面来考虑问题。当然，运行时间越少，占用空间越小的算法肯定是越好的，**但总是会有各种各样的因素导致了运行时间和占用空间不可兼顾**。比如，在程序运行时间过高时，我们可以考虑在空间上做文章，牺牲一定量的空间，来换取更短的运行时间 ( *如打表法就是经典的空间换时间* )。或者在程序对运行时间要求不是很高，而设备内存又有限的情况下，选择占用空间更小，但需要牺牲一定量的时间的算法。

    

    算法拥有 5 个基本特性：**输入**、**输出**、**有穷性**、**确定性**、**可行性**。

    算法追求的目标有 5 个：**正确性、可读性、健壮性、时间复杂度更低、空间复杂度更低**。

    #### 算法复杂度

    上文提到了算法的时间复杂度和空间复杂度，这两者可并称为算法复杂度。

    算法复杂度的定义：在问题的输入规模为 n 的条件下，程序的时间使用情况和空间使用情况。

    > 备注：这里的 "输入规模n" 指的是算法问题输入的数据量大小，对于不同的算法，其定义不同。
    >
    > 试举几例：
    >
    > 排序算法中：n 表示需要排序的元素数量。
    >
    > 查找算法中：n 表示查找范围内的元素总数，比如数组大小、二维矩阵大小、字符串长度、二叉树节点数、图的节点数、图的边界点等。
    >
    > 二进制计算相关算法中：n 表示二进制的展开宽度。

    

    我们可以通过**事后统计与预先估算**两种方式来进行**算法分析**，评估一个算法的复杂度。

    - 事后统计是指，我们在写好一个算法之后，将其交给计算机去执行，在执行完毕后统计所花费的时间和所占用的存储空间
    - 预先分析是指，我们在写好一个算法之后，根据算法所包含的步骤，自行估算其执行所需的时间和存储空间

    **大多数情况下，我们采取预先分析的方法来进行算法分析**

    

    时间复杂度的计算步骤：

    ```c++
    def algorithm(n):
    	fact = 1
    	for i in range(1, n + 1):
    		fact *= i
    	return fact
    ```

    1. ​    找到基本操作语句 ，如上面代码中的第四行
    2. ​    计算基本操作语句**执行次数**的数量级 (保证最高次幂正确即可)
    3. ​    用*O*渐进符表示复杂度，如上面代码的时间复杂度为*$O(n)$*

    **几个注意事项：**

    1. ​    时间复杂度的加法原则：总的时间复杂度等于量级最大的基本语句的时间复杂度

    2. ​    时间复杂度的乘法原则：循环嵌套代码的复杂度等于嵌套内外基本语句的时间复杂度乘积

    	> 如选择排序需要两层执行n次的循环，因此总的时间复杂度为*$O(n^2)$*

    

    **常见时间复杂度的关系:**

    $O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$

    **常见空间复杂度的关系**

    $O(1)<O(log_2n)<O(n)<O(n^2)<O(2^n)$

    

    关于时间复杂度和空间复杂度的详细知识，此处参考[《算法通关手册 (算法复杂度) 》](https://algo.itcharge.cn/00.%E5%BA%8F%E8%A8%80/02.%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/)和[《算法基础—复杂度》](https://oi-wiki.org/basic/complexity/)进行学习，不做一一记录。

    

- ## LeetCode入门及攻略

	参考 [LeetCode 入门与指南](https://algo.itcharge.cn/00.%E5%BA%8F%E8%A8%80/03.LeetCode-%E5%85%A5%E9%97%A8%E4%B8%8E%E6%8C%87%E5%8D%97/)，此处不做赘述。

	

- ## 每日练习

	- ### Question 1 [1929.数组串联](https://leetcode-cn.com/problems/concatenation-of-array/)

	AC代码（c++)

	```c++
	class Solution 
	{
	public:
	    vector<int> getConcatenation(vector<int>& nums)
	    {
	        int n = nums.size();
	        for(int i = 0; i < n; i++)
	        {
	            nums.push_back(nums[i]);
	        }
	        return nums;
	    }
	};
	```

	*解题的心路历程：*

	首先我的第一思路是，定义一个数组ans，将 nums[n] 中的全部元素添加至ans中，循环两次，最后输出ans。

	*算法分析：*

	时间复杂度$O(n)$, 其中$n$为nums中的元素数量，需要将同一个数组遍历两次。

	空间复杂度$O(n)$, 局部变量ans在定义时会申请大小为$2n$的临时空间。

	

	为了进一步优化算法，我想到了向vector类的末尾添加元素的函数 "push_back()" ,并写出了如上代码。

	*算法分析：*

	时间复杂度$O(n)$, 其中$n$为nums中的元素数量，需要将同一个数组遍历两次。

	空间复杂度$O(1)$, 未定义局部变量，输出的数组不计入空间复杂度。

	> 相关链接 [序列式容器](https://oi-wiki.org/lang/csl/sequence-container/)

	- ### Question 2 [0001.两数之和](https://leetcode-cn.com/problems/two-sum/)

		AC代码之一：暴力法 （C）

		```c
		int* twoSum(int* nums, int numsSize, int target,int* returnSize){
		    int *result=NULL;
		    int i,j;
		    *returnSize=2;
		    for(i = 0; i < numsSize-1; i++)
		    {
		        for(j =i + 1; j < numsSize; j++)
		        {
		            if(nums[i] + nums[j] == target)
		            {
		                result = (int*)malloc(sizeof(int)*2);
		                 result[0] = i;
		                 result[1] = j;
		                 return result;
		            }
		        }
		    }
		    return result;
		}
		```

		这是我之前写的一个代码，彼时没有什么算法思维，采用了暴力枚举的方法完成了这个题目

		*算法分析：*

		时间复杂度$O(n^2)$, 其中n为数组中元素数量。

		空间复杂度$O(1)$。

		

		改进后的代码（C++）

		```c++
		class Solution {
		public:
		    vector<int> twoSum(vector<int>& nums, int target) 
		    {
		        unordered_map<int, int> hash_map;
		        for (int i = 0; i < nums.size(); ++i) {
		            auto it = hash_map.find(target - nums[i]);
		            if (it != hash_map.end()) {
		                return {it->second, i};
		            }
		            hash_map[nums[i]] = i;
		        }
		        return {};
		
		    }
		};
		```

		*算法分析：*

		时间复杂度$O(n)$, 其中 $n$是数组中的元素数量。

		空间复杂度$O(n)$, 主要用于哈希表。

		> 相关链接：
		>
		> [无序关联式容器](https://oi-wiki.org/lang/csl/unordered-container/)
		>
		> [auto](https://baike.baidu.com/item/auto/10128)

- ## 总结

	今天学到了数据结构的详细知识，对算法的时空复杂度有了较为详细的了解，初步学习了哈希表的写法。

	但对于哈希表的理解和使用仍不到位，需要加以巩固和联系

